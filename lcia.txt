See notes-attic/lcia.txt for an archived version of this document

==========
Thu Aug 30 12:17:56 -0700 2018

I think today is the day for me to start the LciaResult remodel, as that will dictate how the new exchange world order is supposed to work.





==========
Sat Aug 25 01:14:41 -0700 2018

lcia is handled completely by the quantity and is a wrapper for q relation.
when the catalog is a catalog ref, it uses the root query's lcia engine

still haven't tested any of this or written half of it.

Sat 2018-08-25 13:13:50 -0700

So what do we need to do really?

 - test term manager but it's basically working
 - quantity relation is now implemented by the quantity
   = qlookup maps flowable to clookup
   = quantity clookup should be strict- errors flagged when a duplicate cf is added
 - move do_lcia into quantity interface
   + do_lcia is the only place that creates LciaResults
   + DetailedLciaResult changes to have the following components:
     - contextualized exchange or exchange ref
       	 equivalent to { node ref, flowable term, direction, context, exch val }
       = factor.value
       = location='GLO'
   + input is iterable of exchanges. algorithm is to:
     = lookup flowable in [quantity's qdict or query's qlookup]
     = further lookup context in traversing clookup
     = generate an lcia detailed result from exchange by associating a quantity relation result
     = lcia result has 3 sets:
       * Lcia Scores, which have nonzero results
       * Lcia Zeros, which have non-error zero lookups
       * Fail, which reports exchanges that either had convert fails or flow / reference qty unknown
 - lcia engine is reimagined -> qdb will be ditched and replaced by current lcia engine
   = it's still a basic archive subclass, which reimplements the quantity interface
   = has its own quantity dict which maps quantity term to qlookup owned by the archive instead
   = that qlookup maps flowable to a SClookup
   = SClookup allows multiple cfs for the same flowable/quantity pair and resolves them at query time {i.e. as currently implemented}
 - all this can then be easily de/serialized for http
 - then we need to generate the reference context + flowable sets
 - then qdb is obsolete, it comes out / lcia engine renamed to qdb
 - then we need to reimplement the flowable / context / synonym in the index interface
 => and then we pop back to antelope v2

Future: continue phaseout of uuid;

Wed Aug 29 15:28:39 -0700 2018

Newest brainstorm: abolish LcFlows in favor of flow references only.

wait but why? can't remember. no good reason.

Well, it stemmed from the desire to take the term manager back out of the quantity, since it is really only talking to itself there. then we could abandon set_context() but we would need ....

dammit I am going in circles. And shit I still have not done any refactoring to add_exchange(), to place context as termination! and I don't even KNOW how I would test that shit.

AND lcia is still pending. AND now USDA is starting up. though I suppose I could bill some of this to that. but I do need the system to be working at some point very soon.

Anyway it's time to go get Noe. mm.





==========
Mon Aug 20 11:32:40 -0700 2018

OK, we are midway across a foggy wasteland of a conceptual refactor.  We've taken something that sorta worked and broken it, reimpliemented its core (synonym dict) [better than original for sure] but we haven't figured out what we are going to do with it.  We have a minor slough of legacy code (Qdb and CLookup) and we have a completely reorganized, parted-out codebase with which the old slough is incompatible (AntelopeCatalog is required to do any LCIA?)

So.. for the nth time.. let's review the LCIA PROBLEM and figure out how to fix it THIS AFTERNOON.

Mon 2018-08-20 11:44:50 -0700

So, we have the LciaEngine which, drolly, is simply a wrapper for a captive Qdb.  On my bike ride in this morning, I had the mistaken recollection that Qdb was a SUBCLASS of LciaEngine, but no.

Qdb is an archive, and LciaEngine "interfaces" with a Qdb to perform LCIA.

Qdb is already problematic, with its reliance on catalog refs to populate the database, whereas catalogs are supposed to be an add-on.

Here's what I think Qdb should do.  It should implement the Quantity interface.  WHICH- if we complete our context refactor- is about to get a whole lot simpler.  Here's a full list of methods in the quantity interface, and a mapping to the new interface after the refactor (q = qty, i = index):

 -q profile(flow) --> list of Characterizations
 -q get_canonical(quantity key) --> Quantity Ref

(-i+q? synonyms(any item) --> list of strings)  # ignore this for now
 -i flowables(quantity=None, compartment=None) --> list of name strings
 -i compartments(quantity=None, flowable=None) --> list of name strings

 -q factors(quantity, flowable=None, compartment=None) --> list of Characterizations
 -q cf(flow, quantity, locale=GLO) --> Characterization
 -q quantity_relation(ref_qty, flowable, compartment, q_qty, locale='GLO') --> float

Basically, anything that's part of the quantity interface returns a quantity, characterization, or float (# ignoring synonyms entry because it's really part of the index)

The main utility here is that characterizations are serialized with flows (or stored any which way); the point of the quantity interface is to regroup all that information around the quantity

A characterization value, again, has FIVE parts:
 * reference quantity
 * flowable
 * context
 * query quantity
 * locale

Characterizations with no context apply to the flowable intrinsically
Characterizations with an external ref apply to 

so we want to implement the following mappings:

flow ID -> list of characterizations having that flow's flowable, ref qty, and context
flowable, context -> list of characterizations if a flow is found matching that flowable + context

quantity synonym -> canonical quantity ref

quantity, [flowable,] [compartment] -> list of characterizations
flow, quantity, [locale] -> single characterization
flowable, quantity, compartment -> single characterization
ref qty, flowable, compartment, query qty, [locale] -> float conversion

Mon 2018-08-20 12:39:30 -0700

So now we have a question: should a flow's profile be part of a quantity interface?  and I think the answer is NO, because flows exist in all kinds of archives that don't otherwise implement the quantity interface.  And because I am halfway on my way to making the quantity interface THE LCIA engine.,,

er huh?

I have a total lack of clarity about what I am trying to accomplish.

We want to ABSTRACT + ENCAPSULATE the LCIA computation problem inside the quantity interface.   A profile is a collection of information about a FLOW (or a flowable) and not about a quantity per se

On the other hand, YES, because the inventory interface is built on the exchange relation and there's a powerful argument by symmetry that the quantity interface should be built on the quantity relation.

exchanges, exchange values, inventory -> all exchange relation; all part of inventory

(also part of inventory: foreground lcia, traverse, fragment lcia)
the lcia methods both depend on being given a quantity ref which has the capacity to ensure_lcia(), which means it has a QUERY which implements ensure_lcia_factors(), which really just asks a catalog to load the factors.

THIS is what we are refactoring right now.  How SHOULD it work?

 * Case 0.0: NO CATALOG.  No LCIA Engine.  The process entity's lcia process should be used, and each flow's resident characterization factor should be used in the computation.
 - how does this work in the new flowable-context world? the exchange has a flow, not a flowable. We are not refactoring the basic data type- only changing how it's used.
 -- given that, when creating a new exchange, if termination is None and flow has compartment, then the compartment[-1] becomes the termination
 -- end of story
 - so if the flows in the archive haven't been characterized, the lcia is bupkis? that doesn't work

I think there should be no interfacial way to access LcProcess.lcia() because that shit doesn't work.
Instead, the quantity should be the result of a basic query...

here are the 3 ways to do LCIA:

 0. entity-driven. Load an archive with a process, and the same or another archive with a quantity.  Obtain both process and quantity via basic query.
 - perform process.lcia(quantity, ref_flow=None)
 - if quantity is simply an entity, it will not have a do_lcia() method [because quantity-as-entity doesn't know its own characterization factors.  Only quantity-as-reference has access to its own archive's Quantity Interface.

   although we could simply implement that-- when a characterization is added to a flow, add it to the quantity as well.

   True or False: the quantity itself should implement the quantity interface.

   PRO: no other entity type has a dedicated interface- there is no 'flow interface' or 'process interface' or even 'fragment interface'-- although the fragment does in fact implement the fragment-specific parts of the inventory interface.

   Given that we want to create a special quantity-specific lookup object ALREADY, we may as well simply fold it into the quantity entity, which currently doesn't do much.  Then, in the case of a quantity REF, we have to rely on the query mechanism to implement the interface, which it does using the LciaEngine (or subclass)

   CON: well, for one, this kicks profile out, since a quantity can't report CFs for other quantities that happen to be shared by a flow that it may or may not have. WHere would we put flow.profile()? {{ans: on the flow entity, where it ALREADY IS.  You couldn't ask quantity.profile() because that doesn't make sense.  No change required.}}

   It weakens the conceptual meaning of the interface- which has, heretofore, been something invoked ON AN ARCHIVE.  Write out what the interface is for, and see if that writeup makes sense both ways:

The purpose of the interface architecture is to ensure that the parts of an Antelope computation environment work in a predictable and consistent way.  The interface specifies WHAT queries may be asked.  Some of these queries are asked of an archive as a whole (e.g. archive.processes()), whereas others are asked of specific entities (e.g. process.inventory()).  There doesn't seem to be any rhyme or reason to how those things are arranged:

Index has:
- flows, processes, quantities, lcia_methods, count, contexts, flowables-- all of which are asked of an archive;
- and terminate() and originate() which are asked of a flow but require an archive
- and synonyms(), which is asked of anything with synonyms (and not yet implemented)

Inventory has:
- exchanges, exchange_values, exchange_relation, inventory-- asked of a process (implemented in LcProcess)
- lcia-- asked of a process over a quantity (implemented in LcProcess)
- traverse-- asked of a fragment (implemented in LcFragment)
- fragment_lcia-- asked of a fragment over a quantity (implemented in LcFragment)

Configure: all analogous to existing methods on entities

Background: can only be asked of an archive because the bg matrix must be constructed

Quantity:
- profile, cf-- asked of a flow (implemented in LcFlow)
- get_canonical-- asked of an archive
- factors, quantity_relation-- asked of a quantity (should be

CONCLUSION:
That's pretty conclusive-- the quantity entity should implement quantity-specific methods found in the quantity interface.  MOREOVER. we should seriously consider serializing characterization factors with quantity and grouped by flowable, rather than with flows.  This means REQUIRING that reference quantities have unity cf and not serializing them at all; and then the flows no longer KNOW their own CFs?  How do we de-serialize? by just using flowables?

This seems like a big drag without any clear upside.  Why not let things proceed exactly as they are, BUT also endow LcQuantities with the ability to be aware of their own CFs?  In principle, if the same characterization is added in both places, there is no issue with concurrency- edits to the object affect the object regardless of how it is referenced.  The only problem is when adding new characterizations- should they be cloned only when both entities have the same origin? to what specificity? only when neither entity is a ref?

Right now we use add_characterization() extensively in do_lcia, as a way to avoid repeating the lookup burden by caching the result. This could be premature- maybe the lookup is fast enough not to matter- but are we ready to abandon it?

If we are rebuilding the LCIA engine from scratch, with testing, which we are, maybe we should proceed with no premature optimization.

Mon 2018-08-20 16:45:53 -0700
SO-o-o-o-o-oo-- if we do give quantities this magical ability to recall CFs by flowable and context, then quantities can be the basis for learning / caching.

In the 0 case, where entities handle their own LCIA, the quantity lookup should be more or less lightning fast.

In the 1 case, where we are using an LciaEngine, we do the learning there instead of on the quantity  entities themselves. And the QLookup stacks use reference sets of quantities, flowables, and contexts.

and the 2 case is just like the 1 case.  The only difference is.... well maybe there is no difference.

I think this is how it should go.


so 1- let's write the TermManager.  What does it do?

 - when a flow is added to the db,
   (1) index its identifying information into the flowables dict
   (2) index its compartment information into the compartment manager
 - when a quantity is added to the db,
   do nothing. quantities are self-managing
 - when a characterization is added to the flow:
   (3) if the flow and quantity have the exact same origin, add the characterization to the quantity as well.

 - when a getitem request is received
   (a) first check to see if it is synonymous to a known context; if so, return the context
   (b) then getitem as normal

And that's it.

The TermManager should be used to implement the flowables, compartments, and synonyms methods of the index interface.




 - forget about ensure_lcia() because that doesn't matter
 - the do_lcia() process is implemented in BasicQuery, and simply runs quantity.convert(flow.reference_entity, flow.flowable, flow.context, locale=process['SpatialScope'])
 = it is therefore up to the default quantity implementation to efficiently implement convert()
 = except it will all fail terribly unless both quantity and process use the same flowables and contexts

 1. LciaEngine. 





==========
Thu Jan 11 10:26:15 -0800 2018

Since last September, we have considerably reworked [simplified] the interfaces system, but we are NOT DONE YET.

The following two major changes need to be made, both of which strongly affect LCIA:

 (1) 'flow' as a base entity needs to be abandoned in favor of 'flowable'-- reduce by 10x the number of entities in the db-- and 'context' needs to be added as a new entity.  Flow['Compartment'] is no longer A Thing; instead, an exchange terminates in a context:
 process-flowable-direction-context for elementary flows;
 process-flowable-direction-process for terminated intermediate flows;
 process-flowable-direction-None for cutoff flows (and reference flows)

This vastly simplifies the QuantityInterface implementation.

Moreover-- we have been talking about abandoning Qdb but I think the thing to do is retain Qdb-- and YES, give every antelope container its own private Qdb that it POPULATES by querying a public Qdb-- and have the DetailedLciaResult LOOKUP the factor in the Qdb when the exchange is specified.

Well, maybe that's a bridge too far. But it would be kind of neat if LciaResults were spun out by LciaEngines.

I wonder- let's enumerate all the places LciaResult()s are created, and see if a Qdb is accessible to (m)any of them:

* in LciaResult:
+  - add() 
+  - aggregate()
+  - flatten()
* in LciaResults:
  - __getitem__ [for null]
  - apply_weighting()
* in fragment_flows:
  - frag_flow_lcia() --> replaces traversal_to_lcia(); should be part of LciaEngine?
* in FlowTermination:
  - compute_unit_score [for null]
  - _deserialize_score_cache
* in LcProcess:
  - lcia()
* in EcospoldV2Archive:
  - retrieve_lcia_scores()
* in Qdb:
  - do_lcia()
* in AntelopeV1Client:
  - fragment_lcia()
  - lcia()
  

X in traversal_to_lcia() ==> moved to fragment_flows; unused

OK... we'll look that over a bit later and see if we can shrink that down.  But remember: in cases where the quantity arg is a catalog ref, the Qdb is available via the catalog.

Thu 2018-01-11 13:14:50 -0800

Thinking about this further.... giving the antelope container a Qdb causes problems as well: does it provide a quantity interface? I guess it does- to validate that its factors are the same as a reference.

The whole function of the Qdb is to abstract flow and container descriptors into "flowable" and "context" objects with synonyms.  If we give up the Qdb then we have to re-implement that functionality.

Instead, when we receive a quantity spec- we check to see if it's in our local set of lcia methods- and if not, we retrieve it from our reference Qdb- over the web via the antelope 2.0 interface.  So an antelope client is required to implement the antelope server? that seems dangerous.

They will be different subclasses of LciaEngine-- one for static archives and one for catalogs.  That's the part for me to work on right now.  

The only difference is in load_lcia_factors(). The Static Archive version implements load_lcia_factors(qid) by querying a stored remote Qdb resource.  The Catalog version works as currently written.





----------
==========
----------

