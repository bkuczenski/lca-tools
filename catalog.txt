==========
Tue Sep 19 15:08:01 -0700 2017

Progress?  We made the decision to refactor ForegroundCatalog but we have yet to actually do it.

We DO have a test case, however: to successfully import the AUOMA model.  So let's start there.

No, let's first start by refactoring foreground_catalog, and then using AUOMA as a test case from there.

first mistake of the day: should have merged WaterfallCharts into master instead of into ReCatalog.

oh well live and learn.  ReCatalog will be merged soon enough.

So what do we want to accomplish with Foreground Catalog?

 * if fragments are just another entity type, why do we need another catalog type? ans: we don't.
   - previously, we utilized the difference when de-serializing FlowTerminations.  If they terminate to processes, we created a catalog_ref; otherwise, we just retrieved the fragment itself.
   - but now, we want that catalog ref to stand in for fragment, just as it stands in for process.
   - all we need to do is provide foregrounds as a new LcResource.
     = we can do that with existing code using catalog.new_resource()
     = only we can't EXACTLY, because an LcForeground needs a catalog as an argument.  We can provide it- but we should do so automatically.
     == Ah! catalog is already provided to create_archive() because it's needed in archive_from_json-- so we just need to add another case (done)
   - so wtf is the ForegroundCatalog supposed to do?? we identified 4 features:
     ** ed: hi, I'm ed
     ** __getitem__(self, name) -> retrieves named foreground.  We DID want foregrounds to be scoped distinctly.
     ** frag()
     ** fragment_lcia()

The editor is [only, presently] used in the LcForeground. So why don't we put the fucking editor straight in the fucking foreground?
 1. because the editor needs a Qdb
 2. because we only want to have one editor. (??)

So why don't we just put the fucking editor in the LcCatalog?
 3. because we want to disallow fragment creation for simple catalogs? seems like an odd / quixotic decision.
 4. because LcCatalog is already too heavy? just like catalog_ref?

Getitem could be useful for catalogs in general-- presently it pulls the archive by name.  could just transplant that.

Frag() -- aha, now this is tricky.  We need a way of spooling through the existing, LOADED foregrounds and looking for a fragment by ref or leading uuid portion.-  That's as simple as filtering by type

Fragment LCIA. This gets to a more fundamental question.
Fragment LCIA operates on a list of FragmentFlows (and relies on flow terminations caching nested fragment flows internally)
 - it needs qdb
 - it needs to tell qdb to load factors
 - it needs to call itself recursively.

So... how are we going to be invoking this in the REAL world?  if we are going to be calling it as a catalog_ref method, then we want to model the behavior of the entity itself.
EXCEPT-- a fragment ENTITY does not know how to compute its own LCIA-- it needs a catalog for that.
Is there a precedent? YES- catalog_refs have all sorts of methods (mainly background methods) that don't work on literal entities.

So- IF we made Fragment LCIA a catalog_ref function-- then what would it do, and where would it be implemented?
 ans: it would be implemented in the inventory interface... the InventoryImplementation inherits the BasicImplementation, which keeps a pointer to the catalog, which has a Qdb
 Better- the BasicImplementation is also one of n places where we're already keeping a log of characterized quantities-- but that's a different list-- because that's a list of quantities that are looked up externally and applied to native flows in the archive
 so hmm.

NO NO NO. The Qdb ALONE should keep track of what quantities have been loaded into the Qdb.  Right now that is not done because the Qdb only has add_cf, not add_all_cfs_for_quantity.

I'm seriously recursing here....

where are we at?

AUOMA Testing
-> ForegroundCatalog refactor
  -> fragment_lcia()
    -> catalog_ref()
      -> Catalog.load_lcia_factors()
        -> Qdb.get_canonical_quantity()

What on earth do we want a canonical quantity for?  ans: the canonical quantity is the actual entity stored in the Qdb.  We want to retrieve it if we want to know whether it's loaded?  BUT- the literal (canonical) quantity ITSELF can't tell me its factors, because that is a catalog function.

Where is get_canonical_quantity used? 6 places
 * LcCatalog.lcia() -> to test if loaded; as argument to do_lcia
 * LcCatalog.load_lcia_factors() -> to store a list of loaded quantities
 * Qdb.do_lcia() -> to dance around a bit before retrieving the same quantity with get_quantity() (which is functionally identical)
 * in BackgroundImplementation.bg_lcia(), in an if False: block (linked with BasicImplementation.characterize()
 * in QuantityImplementation.lcia_methods(), in an apparent NOP (return value not used)
 * in QuantityImplementation.quantities(), in the same apparent NOP (return value not used)
   = now it's not really a NOP because it calls _get_q_ind, which ADDS the quantity if it doesn't already exist. But isn't there a better way of doing that?

More to the point- the original question still stands: Why do we ever WANT to obtain a "canonical" quantity?  What does it allow us to do that having a quantity_ref.uuid doesn't?



==========
Tue Aug 01 13:25:08 -0700 2017

This is still stalled out.

We're having a breakdown of design discipline.

Tue 2017-08-01 15:14:48 -0700

Big improvement (not yet tested though): re-designed QueryInterface to inherit from a whole bunch of abstract base classes that each only specifies how different resource types should behave. Then instead of re-inheriting from the QueryInterface, I now have a separate set of implementation classes that actually implement the endpoints.

NOTHING is tested or even compiled yet.  but it already feels better.

Next tasks: get stuff out of catalog.py, and then get more stuff out of foreground_catalog.py

Tue 2017-08-01 22:59:37 -0700

OK- LcCatalog actually looks pretty good. We have:
 - a whole list of imports, many of them local

Line 55: class LcCatalog(object):
then we have 60 lines of root-path-dependent constants

line 118: __init__
     _rootdir
     _resolver
     _entities ** DO WE REALLY WANT THIS? I THINK WE SHOULD GET RID OF THIS **
     _qdb

The actual catalog:

     _archives: source to LcArchive
     _names: ref:interface to source
     _nicknames: shorthand -> source

     _lcia_methods: ** WHERE SHOULD I KEEP TRACK OF THIS? **  (already 2+ places: in catalog, in qdb, in basic)

Lines 147-230: make, get, retrieve archives and resources

Lines 245-287: names, sources, and interfaces

lines 288-381: index, cache, and archive resources

lines 382-418: dereference and retrieve entities

lines 419-447: get interfaces

lines 448-472: Utilities
	query(origin) - returns a CatalogQuery
	lookup(ref) - ref = CatalogRef - returns "the lowest-priority origin to contain the entity". sounds like it could have greater utility.
	fetch(ref) - this should also permit greater specification
	entity_type(ref) - could probably be done more efficiently

lines 473-eof (538): Qdb Interaction
	is_elementary(flow)
	is_loaded(lcia) ** THIS AGAIN **
	load_lcia_factors(ref)
	lcia(p_ref, q_ref) -- the core function of the catalog
	annotate(flow, quantity, ...) -- gets stored in local Qdb
	quantify(xxx) - not helpful
	   

Glue / misc:
line 144-146: quantities()
line 232-235: privacy(ref)
line 236-244: flowables grid

All seem fair.

(commit)

Now, turning to foreground_catalog...

WHY, exactly, are we creating an entire separate (and ad hoc) infrastructure for handling "foregrounds", which in fact correspond to physical sources in the EXACT same way that LcResources do, and we ALREADY HAVE a catalog for handling LcResources?

That is a very good question. I think basically all that stuff can COME OUT, modulo some light details regarding search order / preference / priority.

line 18-26: class ForegroundCatalog(LcCatalog): and docstring
lines 27-34: a list of foregrounds known outside the LcResolver context
lines 35-45: we want sources to exclude foregrounds for some reason? so we ARE storing foregrounds in the same dict as other sources, BUT monkeying with the machinery to except them?

line 46: __init__
     _foregrounds -> only loaded ones (so, unlike _archives how?)
     _known_fgs -> redundant to resolver
**     ed -> Hi, I'm ed.

** lines 53-65: __getitem__ this is maybe appealing
lines 66-78: this terrible name-canonicalizing. Why am I forcing names to start with 'foreground' and have no specified interface, when the existing machinery already provides ref:foreground?
ans: because I want to be able to specify a scope of all foregrounds? well, just make the resolver work with '' input

lines 79-109: load / add foregrounds
lines 110-118: known foregrounds management. again, this is a matter that LcResources already solve
lines 119-127: listing + showing foregrounds

Then we have 128-155: re-implement _dereference as _retrieve for no good reason
** lines 156-164: the first foreground-specific feature, other than __getitem__ but that is also good: get fragment by reference or leading portion of uuid

lines 165-184: Re-implemented lookup() and fetch()

** lines 185-217 fragment_lcia(fragmentflows, q_ref)

OK. so about 32 + 8 + 12 + 1 = 25% of the class is worth keeping.  The rest should be wrapped up in LcCatalog.

Wed 2017-08-02 15:44:19 -0700

So how do we go about this?

 * Do we want 'foreground' to be included in INTERFACE_TYPES?
   - are there any characteristics of the foreground interface that are not shared by any of the others?
   - are there compelling circumstances when I would NOT want to look in foreground resources?
   = does the order of inquiry matter, or is that handled with resource priorities?

INTERFACE_TYPES uses (8):
 iquery:
  (as arguments to _perform_query)
  - get_item
  - get
  - get_reference
  - get_uuid
  (as default interfaces to resolve)
  - resolve

 test_catalog:
  - initialize uslci_bg resource

 catalog:
  - lookup(), as argument to _dereference

 lc_resource:
  - to validate interfaces argument

So add_foreground should create a resource that has 'foreground', 'index', 'inventory', and 'foreground' should be in INTERFACE_TYPES.

the only thing foregrounds can do that others can't is be WRITEABLE.  So foreground interface is all POST routines.  everything else either belongs to the catalog (fragment_lcia) or .. is traverse() and can go in inventory.  there aren't any others.

also need a scenarios interface.

(the interfaces lark is quite a gas, isn't it?)

so foreground is all about creating a foreground, creating flows, setting properties, creating fragments and specifying exchange values, and terminating. and setting balance
that's it.
scenarios-> those are just query args for exch val and termination

Thus we add 'foreground' to INTERFACE_TYPES, and we create READONLY_INTERFACE_TYPES which excludes it.

Then almost all of the above cases (6 of 8) should in fact use READONLY; and only resolve() and lc_resource validation should use the full list.

 * What other changes need to be made in order to have the LcResolver handle foregrounds?

 * What queries need to be supported in the foreground query interface?
   Foreground interface is the same as inventory interface, except that it allows for the archive to contain fragments.
   = is there an affirmative characteristic of LcArchive that PREVENTS it from storing fragments? ANS: NO

Foreground audit!! Now this was recently rewritten, so I imagine it is generally useful, but let's take a look:

line 22-26: class LcForeground(LcArchive): + docstring
line 27-30: load_json_file-- this could be part of the base LcArchive; I don't see why not
line 31-46: external references mapping-- this could be part of the base LcArchive
line 47-63: __init__(path, catalog)
     Requires a catalog to deserialize fragments
     Requires that it be a foreground catalog i.e. that has an entity editor
line 64-67: editor property
line 68-77: create resolved catalog refs; also actual entities from foregrounds (DEPRECATED)
line 78-90: override add to merge instead of skipping
line 91-96: save-- write entity file, serialize fragments
line 97-167: create fragments
line 168-172: clear score caches
line 173-180: path-specific constants
line 181-240: access / retrieve fragments
line 241-245: draw tree
line 246-250: override check_counter
line 251-259: assign external references
line 260-293: load fragments
line 294-304: outmoded child_flows fn
line 305-325: save fragments
line 326-360: find linked terms and orphans.

Things to fix:
 - old child flows
 - reorganize
 - remove fragment handling from LcArchive.add(), put it into Foreground.add(). This prevents LcArchives from adding fragments.  raise (and catch?) TypeError.
 - Terminations to fragments shjould always reference the parent fragment, with the termflow used to indicate if the fragment is not being run directly.

 - figure out the upstreaming issue.  Is this just a foreground feature now? should it always and only use the catalog's native Qdb?

We need to think this over more.






==========
Tue May 02 14:53:31 -0700 2017

This is STALLED OUT.

Here's the approach:

 The CatalogRef is the magic key.  It implements all the API interfaces, and then it asks the catalog to satisfy them.
 The Catalog leans heavily on the resolver to get from a semantic ref to a physical archive.
 


==========
Tue Apr 25 15:07:52 -0700 2017

An LcCatalog provides an automated service for obtaining information about LCA data objects.

There are four different forms of (read-only) information available to be queried (see API.md):

 * Quantity data are informations about the quantitative properties of flows.  These are stored in a quantity database, which can exist independently of any inventory information.  Quantity data apply to 'flowables', often when going into or coming out of different 'compartments'.  An LcFlow is a flowable and a particular compartment.

 * Catalog data are metadata and non-quantitative data about entities, including their names, characteristics. At least a subset of these are generally publicly available for all entities.

 * Foreground data are quantitative data that describe computational information about the entities when used in models.  For flows, these include characterizations. For processes, these include exchanges.

 * Background data are quantitative data that describe the aggregated life cycle inventory or life cycle impact assessment results for processes embedded in computable databases.

When a catalog ref is looked up, the catalog specifies whether the entity is known to the catalog in a catalog, fg, or bg sense.

This means that the catalog is also separate from the foreground in a way that's different from before. it's more focused on data retrieval (as should be).

We still haven't broached the study construction- which comes next.

Thu 2017-04-27 12:17:52 -0700

But-- for the time being, the important facts are: the catalog PROVIDES access to the API routes specified in API.md.  The Catalog CAN be implemented as a web service.  The catalog CAN ALSO operate as a web CLIENT- in which case the data source would be another instance of the catalog service-- but this is a complicated step that requires the catalog to de-serialize JSON data.  That can get folded into the archive factory, though, I think.

SO, TO SUMMARIZE:
 - the LcCatalog is the culmination of the semantic catalog work. the idea is to translate a REST-style query into usable lca data. I *think* the API spec is adequate to do complete LCA. (minus uncertainty; minus study-specific allocation).

 - The catalog operates on a catalog ref, which is an origin + external ref, which should be unique.

 - the STUDY should use the catalog to obtain data and also enable the user to directly input data. Everything is fragments; nothing is processes.

 - fragments are basically exchanges, and terminations are complementary exchanges.  Thus a terminated fragment is a link.

REMAINING WORK:

 - implement the catalog, obviously

 - implement the CatalogInterface, ForegroundInterface, BackgroundInterface.  get them tested and running.  Those interfaces are eminently testable.

 - re-design the foreground to be the study-- construct fragments incrementally using the API queries.

 - for now we don't need fg lcia, since all the child flows will be rendered as fragments.  If we want, we can do something where 'flows not present as child fragments but present in the process inventory can be characterized'.  but rather than jump to that, we should AUTOMATICALLY CREATE SUB-FRAGMENTS from processes, store the process ref, and then write a routine to update fragment exchange values from queries.  best of all worlds.

 - lastly, write the web service, and get it running on the lca-tools-datafiles data.  THAT will be instantly disruptive.

time to get the bus.

PLUMBING

OK, in the interest of postponing ACTUAL PROGRAMMING for as long as possible, let's continue to think through exactly how this will work.

Fri 2017-04-28 18:23:14 -0700

OK.  SOME modest progress.




Option 1: Prototype the CatalogInterface, ForegroundInterface, and BackgroundInterface.

 * CatalogInterface inherits from NsUuidArchive
 * key is '/'.join(origin, external_ref)
 * Catalog's entity list acts as a cache -- stores non-quantitative data for all entities requested (quant too?)
 * CatalogInterface implements the API
 * CatalogInterface composed with a Qdb (separate interface)
 * CatalogInterface maintains a collection of LcArchives

 * CatalogInterface has a resolver input file that maps semantic roots to lists of data sources
   - each data source has attributes:
     = Priority - lowest priority accessed first
     = dataSourceType - argument to archive_factory
     = dataContents - controlled vocabulary: 'catalog', 'foreground', 'background'
       ** foreground provides catalog
       ** foreground archive input to BackgroundManager provides background
       ** background provides catalog
       ** background cannot provide foreground
     = ExcludeRoutes: list of API routes that the source should not provide
     = AccessControl: controlled vocabulary:
       ** 'open' -- any query is answered
       ** 'metered' -- authentication must be provided; every query is billable
       ** 'protected' -- authentication must be provided; authorization TBD
       ** ... others TBD

There is going to have to be some kind of regression.  When a query is received, the resolver needs to:
 - receive the query, including origin + ref + authentication info
 - determine whether the catalog can answer the query at all
   = determine if a source is known for the given origin
   = determine if the request is authorized to access the source
     ** list the same source multiple times?? sure-- the thing that gets 
   = determine if the query type (catalog, fg, bg) is available
 - determin
