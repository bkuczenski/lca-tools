==========
Wed Nov 01 10:43:46 -0700 2017

Hard to believe how long this project has been going and how piss poor it all is.

The best thing going right now is the process_ref interface, which provides all the information required about nodes in a process-flow network.

The process API doesn't even match the process_ref API though.  and fragments are just utterly confused.

Here's what we should do:
 - rearrange the process API to match the process_ref
   * filter that through usage
 - make the fragment API match the relevant aspects of process_ref
 - simply extend fragment to fragment_ref

We also wind up back at the same quandary regarding specifying LCIA quantities over REST. I guess they should be query args.  e.g. API_ROOT/semantic.origin/p_entity_id/lcia?quantity=semantic.origin/q_entity_id&locale=x
with the default locale of course being the process's SpatialScope


I keep getting stuck on "how should this work REALLY?"

How it should work is this:
 - the interface specification should be the master of all things
 - fragments should behave like bg processes if they are remote, and like foregrounds if they are local
 x except we don't want remote fragments to behave like processes because we still want to enable deep stage aggregation, a la the used oil study, which is required for AUOMA.
 - we can pre-aggregate on the remote side.  presumably we would want to allow the remote authors to specify the aggregation.  But they can do that by setting the descend flag during subfragment construction.
 - I think we need to implement unit_inventory and then derive inventory + exchanges from that
 - unit_inventory delivers two sets of fragmentflows: exterior, interior
   = inventory + exchanges convert the exterior ones to exchanges and return the list
   = exchange relation can work the same
   = fg_lcia--> not sure we want to implement this but we could conceivably do fragment_lcia only for non-background ffs
   = foreground--> same as traversal
   = is_in_background--> false for all fragments
   = ad, bf--> can conceivably construct these from interior ffs
   = lci--> to be implemented
   = bg_lcia--> this is just fragment_lcia
   = fragment lcia -> score_cache -> if term is remote, just recurse at query time. NOPE NOPE NOPE
     == that just means that remote queries will result in repeated traversals. that is maybe not efficient.
     == plus we will need to serialize the entire LciaResult and then deserialize it.
     == plus that prevents local referents from overriding stage names
   = fragment_lcia -> score_cache -> if term is remote, DO NOTHING.
     == we DO need to extend fragment_refs to include a 'private' flag indicating whether agg is mandatory
     = given that, if descend is allowed, we just receive and deserialize the interior ffs as current
     = if descend is false locally, we receive and deserialize interior ffs as current and store them
       == when fragment lcia comes around, we recurse on the list of ffs per usual and locally compute unit scores
     = if descend is not allowed remotely, we receive a single agg interior ff
       == when fragment lcia comes around, we recurse on the single agg interior ff

OK this is going well.  We DO need a mechanism to mark fragments as private. But that's not urgent. For now we just need to implement unit_inventory.

and refactor process to match process_ref
and continue fragment and fragment_ref refactor
and work through the traversal snarl!
and implement frag_flow_lcia in LcFragment (or make a dedicated class?)

fuck this is all a big mess.

Another problem is, all process queries expect/require a ref_flow specification, but all fragment queries have a single reference flow but expect/require a scenario specification.  So the traversal machinery still must distinguish between them.

On that note, let's review the traversal machinery.

Three major blocks:
 1. determine exchange value w.r.t. node balance
 2. recurse over children, process case
 3. recurse over children, fragment case

Ultimately we want 2 and 3 to align. but they do need to be different.  processes are static but frags are not.
Can we / do we want to implement conservation flows on fragment children?
 

==========
Thu Apr 20 13:01:43 -0700 2017

Notes on current de-facto and future idealized interfaces between components.

###########################################################################
PART 1: EXISTING INTERFACES, empirical
###########################################################################


--- Data File Storage and Retrieval


Archive: ('physical' layer)
 + init: path, query string (remotes: append to request), cache (remotes: dl local copy)
   + cache is a recursive physical archive
 - listfiles(in_prefix) (local only)
 - countfiles (local only)
 - writefile (local uncompressed only)
 - readfile

ArchiveInterface: caching digest of contents of an archive
 - add
 - [getitem] by key or UUID
 + upstream-- look first
   + truncate upstream: TODO
 - retrieve or fetch
 - search
 - validate entity list
 - serialize, write to file

 - load all (must be implemented in subclass)
 - fetch (must be implemented in subclass)

LcArchive(ArchiveInterface):
 - deserialize process, flow, quantity from json
 - add entity and children
 - processes, flows, quantities, lcia_methods
 - terminate
 : serialize p, f, q

NsUuidArchive(LcArchive):
 + create a UUID3 namespace for translating keys to ID



--- Data Entities

LcEntity:
 - origin, uuid, external_ref, entity_type
   + entity's true id should be origin + external_ref
 - signature_fields -- type-specific list of mandatory properties
 - properties -- exclusive of signature fields (why? never used)
 - update (properties dict)
 - validate (called by archive to validate all entities):
   + valid entity_type
   + valid reference (None allowed)
   + signature fields all defined
 - serialize
 + show() - pretty print
 - eq: origin, entity type, external ref all the same
 - merge:
   - differing origins allowed! (only because origins right now are not semantic)
   + add missing properties; do not overwrite existing properties

LcQuantity:
 + reference entity is LcUnit -- which is just a dummy: unitstring with an external ref
 - unit : return self.reference_entity.unitstring()
 - is_lcia_method (has_propoerty 'Indicator')
 - convert: use existing 'UnitConversion' property as spec'd

LcFlow:
 + reference_entity is LcQuantity
 - add_characterization (quantity, reference=False, value=None, ...)
   + ... passed to characterization.add_value()
 + has_characterization
 - del_characterization
 - characterizations (generator)
 - factor, cf (backwards??) 
 - convert (to=quantity, fr=quantity)  both default to reference_entity
 + match: check if uuids or names or cas numbers or external refs are equal
 + profile: list of characterizations
 + serialize: include characterizations
 - merge
   - add characterizations, only if missing

LcProcess:
 + reference_entity is set of Exchanges.
 + inventory(ref): print + return list of exchanges
 - exchange(flow, direction): generate matching exchanges
 - exchanges(reference) generate allocated exchanges
 + has_exchange(flow, dir)
 - find_reference(ref) flexible input
 - add_reference(flow, dir) *both required*
 - remove_reference(ref_exch)
 + references: generator
 - reference(flow): return one; error if ambiguous
 - allocate_by_quantity(quantity): perform automatic allocation
 - is_allocated(ref) - determine whether ref appears as allocation key in any exchanges
 - remove allocation(ref)
 - add_exchange(flow, dirn, ...)
 + lcias(quantities): return LciaResults
 - lcia(quantity): return LciaResult (flowdb????) should only use flows' native cfs
 - serialize: include exchanges
 x merge not implemented











ForegroundQuery:
 - requires ForegroundManager, which provides:
   = retrieve quantities from foreground archive
   = retrieve LcFragment or LcProcess by reference
   = perform fragment_lcia of fragment (really owned by the fragment)
     = this routine must accept the following keyword arguments:
       * scenario
       * observed
       * scale
       * normalized
     = this routine must return an LciaResults object
     = this requires unit scores to be computed in advance
   = perform fg_lcia of the process
     = this routine must return an LciaResults object

 - user provides fragment references, which the foreground manager must resolve
 - user provides quantity references, which the foreground manager must resolve
 - user provides LciaWeightings, which must be constructed by the user

LciaResults:
 - implement dict of quantity uuid to LciaResult having that quantity
 - input to self._do_stages

LciaResult: (this is the big one) (need testing!)
 - aggregate(self, key=lambda) returns an LciaResult having the same total, with entries grouped by key
 - components(self) returns a list of entries in the result
 - dict of component key to AggregateLciaScore 
   - each component has a cumulative_result property
 
lots of muddiness regarding the LciaResult / AggregateLciaScore / DetailedLciaResult interface

In particular: I want to dispense with explicit factors wherever possible: the factor can be queried from the exchange's flow.  To do otherwise would imply 





###########################################################################
PART 2: NEW INTERFACES, conceptual spec
###########################################################################

What are the computations that we need to do? refer to workflows spec:

 * list process instances, flows, quantities
 * find process instances that terminate an exchange
 * get inventory (list of exchanges w.r.t. reference)
 * get exchange value for a given exchange
 * compute life cycle inventory
 * [compute life cycle impact assessment]
 * get characterization

SO-- from a functional perspective, if we break this into four groups:

 QuantityInterface:
q0 - get characterization for flowable | compartment | locale | ref qty
      Input: ref qty, flowable, compartment, query quantity, [optional locale]
      Output: value
q1 - show quantity metadata
      Input: quantity entity
      Output: quantity metadata document (JSON serialization)
q2 - show flowables characterized for qty + compartment
      Input: query quantity, [optional compartment string]
      Output: list of flowable strings
q3 - show compartments characterized for qty + flowable
      Input: query quantity, [optional flowable string]
      Output: compartment strings
q4 - show quantities characterized for flowable + compartment
      Input: flowable string, [optional compartment string]
      Output: list of quantities

 CatalogInterface:
c0 - list process instances, flows, quantities known to an archive
      Input: semantic ref, entity type, [optional search params?]
      Output: list of entities
c1 - show metadata for one process instance
      Input: one process
      Output: process metadata document (JSON serialization)
c2 - show metadata for one flow instance
      Input: one flow
      Output: flow metadata document (JSON serialization)
c3 - show reference entity for process instance
      Input: one process
      Output: list of exchanges
c4 - show reference entity for flow instance
      Input: flow
      Output: quantity
c5 - show processes that terminate an exchange (directions complement; reference only)
      Input: exchange, or flow + direction
      Output: list of processes
c6 - show processes that originate an exchange (directions match; reference only)
      Input: exchange, or flow + direction
      Output: list of processes
..... other semantic services

 ForegroundInterface:
f0 - list process exchanges
      Input: process
      Output: list of valueless exchanges
f1 - get exchange values for a given exchange w.r.t. reference
      Input: exchange + opt. reference
      Output: exchange value
f2 - compute foreground LCIA
      Input: process, query quantity
      Output: LciaResult for quantity
f6 - show processes that originate an exchange (directions match; reference or non-reference)
    (enclosed access to flow db)

 BackgroundInterface:
b0 - list foreground processes
b1 - list background processes
b2 - list cutoff flows
b3 - get lci for process (bx~)
b4 - get agg background dependencies for process (ad~)
b5 - get agg cutoffs for process (bf~)
b6 - get background LCIA
    (enclosed access to flow db)


 Study Construction:
s0 - create reference fragment with flow + direction
s1 - terminate fragment with:
     Null -> IO
     0 -> FG
     uuid -> 


Activities we want to do:

When building a model:
 - choose or create a flow
 - add characterizations to that flow
 - terminate the flow => to foreground, to background
 - get inventory

When traversing a model:
 - get characterizations for foreground emissions
 - get exchange values of listed exchanges
 - compute LCIA of non-listed exchanges (fg lcia)
 - compute LCIA of background nodes (bg lcia)



How will it work?

We have an LcCatalog, which dereferences origins + external ids to entities stored in LcArchives.  
