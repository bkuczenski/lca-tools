==========
Thu Apr 20 13:01:43 -0700 2017

Notes on current de-facto and future idealized interfaces between components.

###########################################################################
PART 1: EXISTING INTERFACES, empirical
###########################################################################


--- Data File Storage and Retrieval


Archive: ('physical' layer)
 + init: path, query string (remotes: append to request), cache (remotes: dl local copy)
   + cache is a recursive physical archive
 - listfiles(in_prefix) (local only)
 - countfiles (local only)
 - writefile (local uncompressed only)
 - readfile

ArchiveInterface: caching digest of contents of an archive
 - add
 - [getitem] by key or UUID
 + upstream-- look first
   + truncate upstream: TODO
 - retrieve or fetch
 - search
 - validate entity list
 - serialize, write to file

 - load all (must be implemented in subclass)
 - fetch (must be implemented in subclass)

LcArchive(ArchiveInterface):
 - deserialize process, flow, quantity from json
 - add entity and children
 - processes, flows, quantities, lcia_methods
 - terminate
 : serialize p, f, q

NsUuidArchive(LcArchive):
 + create a UUID3 namespace for translating keys to ID



--- Data Entities

LcEntity:
 - origin, uuid, external_ref, entity_type
   + entity's true id should be origin + external_ref
 - signature_fields -- type-specific list of mandatory properties
 - properties -- exclusive of signature fields (why? never used)
 - update (properties dict)
 - validate (called by archive to validate all entities):
   + valid entity_type
   + valid reference (None allowed)
   + signature fields all defined
 - serialize
 + show() - pretty print
 - eq: origin, entity type, external ref all the same
 - merge:
   - differing origins allowed! (only because origins right now are not semantic)
   + add missing properties; do not overwrite existing properties

LcQuantity:
 + reference entity is LcUnit -- which is just a dummy: unitstring with an external ref
 - unit : return self.reference_entity.unitstring()
 - is_lcia_method (has_propoerty 'Indicator')
 - convert: use existing 'UnitConversion' property as spec'd

LcFlow:
 + reference_entity is LcQuantity
 - add_characterization (quantity, reference=False, value=None, ...)
   + ... passed to characterization.add_value()
 + has_characterization
 - del_characterization
 - characterizations (generator)
 - factor, cf (backwards??) 
 - convert (to=quantity, fr=quantity)  both default to reference_entity
 + match: check if uuids or names or cas numbers or external refs are equal
 + profile: list of characterizations
 + serialize: include characterizations
 - merge
   - add characterizations, only if missing

LcProcess:
 + reference_entity is set of Exchanges.
 + inventory(ref): print + return list of exchanges
 - exchange(flow, direction): generate matching exchanges
 - exchanges(reference) generate allocated exchanges
 + has_exchange(flow, dir)
 - find_reference(ref) flexible input
 - add_reference(flow, dir) *both required*
 - remove_reference(ref_exch)
 + references: generator
 - reference(flow): return one; error if ambiguous
 - allocate_by_quantity(quantity): perform automatic allocation
 - is_allocated(ref) - determine whether ref appears as allocation key in any exchanges
 - remove allocation(ref)
 - add_exchange(flow, dirn, ...)
 + lcias(quantities): return LciaResults
 - lcia(quantity): return LciaResult (flowdb????) should only use flows' native cfs
 - serialize: include exchanges
 x merge not implemented











ForegroundQuery:
 - requires ForegroundManager, which provides:
   = retrieve quantities from foreground archive
   = retrieve LcFragment or LcProcess by reference
   = perform fragment_lcia of fragment (really owned by the fragment)
     = this routine must accept the following keyword arguments:
       * scenario
       * observed
       * scale
       * normalized
     = this routine must return an LciaResults object
   = perform fg_lcia of the process
     = this routine must return an LciaResults object

 - user provides fragment references, which the foreground manager must resolve
 - user provides quantity references, which the foreground manager must resolve
 - user provides LciaWeightings, which must be constructed by the user

LciaResults:
 - implement dict of quantity uuid to LciaResult having that quantity
 - input to self._do_stages

LciaResult: (this is the big one) (need testing!)
 - aggregate(self, key=lambda) returns an LciaResult having the same total, with entries grouped by key
 - components(self) returns a list of entries in the result
 - dict of component key to AggregateLciaScore 
   - each component has a cumulative_result property
 
lots of muddiness regarding the LciaResult / AggregateLciaScore / DetailedLciaResult interface

In particular: I want to dispense with explicit factors wherever possible: the factor can be queried from the exchange's flow.  To do otherwise would imply 





###########################################################################
PART 2: NEW INTERFACES, conceptual spec
###########################################################################




LciInterface:
 - specialization of the LcArchive interface
 - adds LCI computation from a single, monolithic background database such as USLCI or an ecoinvent system model / ocelot spec

