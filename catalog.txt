==========
Tue Aug 01 13:25:08 -0700 2017

This is still stalled out.

We're having a breakdown of design discipline.

Tue 2017-08-01 15:14:48 -0700

Big improvement (not yet tested though): re-designed QueryInterface to inherit from a whole bunch of abstract base classes that each only specifies how different resource types should behave. Then instead of re-inheriting from the QueryInterface, I now have a separate set of implementation classes that actually implement the endpoints.

NOTHING is tested or even compiled yet.  but it already feels better.

Next tasks: get stuff out of catalog.py, and then get more stuff out of foreground_catalog.py

Tue 2017-08-01 22:59:37 -0700

OK- LcCatalog actually looks pretty good. We have:
 - a whole list of imports, many of them local

Line 55: class LcCatalog(object):
then we have 60 lines of root-path-dependent constants

line 118: __init__
     _rootdir
     _resolver
     _entities ** DO WE REALLY WANT THIS? I THINK WE SHOULD GET RID OF THIS **
     _qdb

The actual catalog:

     _archives: source to LcArchive
     _names: ref:interface to source
     _nicknames: shorthand -> source

     _lcia_methods: ** WHERE SHOULD I KEEP TRACK OF THIS? **  (already 2+ places: in catalog, in qdb, in basic)

Lines 147-230: make, get, retrieve archives and resources

Lines 245-287: names, sources, and interfaces

lines 288-381: index, cache, and archive resources

lines 382-418: dereference and retrieve entities

lines 419-447: get interfaces

lines 448-472: Utilities
	query(origin) - returns a CatalogQuery
	lookup(ref) - ref = CatalogRef - returns "the lowest-priority origin to contain the entity". sounds like it could have greater utility.
	fetch(ref) - this should also permit greater specification
	entity_type(ref) - could probably be done more efficiently

lines 473-eof (538): Qdb Interaction
	is_elementary(flow)
	is_loaded(lcia) ** THIS AGAIN **
	load_lcia_factors(ref)
	lcia(p_ref, q_ref) -- the core function of the catalog
	annotate(flow, quantity, ...) -- gets stored in local Qdb
	quantify(xxx) - not helpful
	   

Glue / misc:
line 144-146: quantities()
line 232-235: privacy(ref)
line 236-244: flowables grid

All seem fair.

(commit)

Now, turning to foreground_catalog...

WHY, exactly, are we creating an entire separate (and ad hoc) infrastructure for handling "foregrounds", which in fact correspond to physical sources in the EXACT same way that LcResources do, and we ALREADY HAVE a catalog for handling LcResources?

That is a very good question. I think basically all that stuff can COME OUT, modulo some light details regarding search order / preference / priority.

line 18-26: class ForegroundCatalog(LcCatalog): and docstring
lines 27-34: a list of foregrounds known outside the LcResolver context
lines 35-45: we want sources to exclude foregrounds for some reason? so we ARE storing foregrounds in the same dict as other sources, BUT monkeying with the machinery to except them?

line 46: __init__
     _foregrounds -> only loaded ones (so, unlike _archives how?)
     _known_fgs -> redundant to resolver
**     ed -> Hi, I'm ed.

** lines 53-65: __getitem__ this is maybe appealing
lines 66-78: this terrible name-canonicalizing. Why am I forcing names to start with 'foreground' and have no specified interface, when the existing machinery already provides ref:foreground?
ans: because I want to be able to specify a scope of all foregrounds? well, just make the resolver work with '' input

lines 79-109: load / add foregrounds
lines 110-118: known foregrounds management. again, this is a matter that LcResources already solve
lines 119-127: listing + showing foregrounds

Then we have 128-155: re-implement _dereference as _retrieve for no good reason
** lines 156-164: the first foreground-specific feature, other than __getitem__ but that is also good: get fragment by reference or leading portion of uuid

lines 165-184: Re-implemented lookup() and fetch()

** lines 185-217 fragment_lcia(fragmentflows, q_ref)

OK. so about 32 + 8 + 12 + 1 = 25% of the class is worth keeping.  The rest should be wrapped up in LcCatalog.

Wed 2017-08-02 15:44:19 -0700

So how do we go about this?

 * Do we want 'foreground' to be included in INTERFACE_TYPES?
   - are there any characteristics of the foreground interface that are not shared by any of the others?
   - are there compelling circumstances when I would NOT want to look in foreground resources?
   = does the order of inquiry matter, or is that handled with resource priorities?

INTERFACE_TYPES uses (8):
 iquery:
  (as arguments to _perform_query)
  - get_item
  - get
  - get_reference
  - get_uuid
  (as default interfaces to resolve)
  - resolve

 test_catalog:
  - initialize uslci_bg resource

 catalog:
  - lookup(), as argument to _dereference

 lc_resource:
  - to validate interfaces argument

So add_foreground should create a resource that has 'foreground', 'index', 'inventory', and 'foreground' should be in INTERFACE_TYPES.

the only thing foregrounds can do that others can't is be WRITEABLE.  So foreground interface is all POST routines.  everything else either belongs to the catalog (fragment_lcia) or .. is traverse() and can go in inventory.  there aren't any others.

also need a scenarios interface.

(the interfaces lark is quite a gas, isn't it?)

so foreground is all about creating a foreground, creating flows, setting properties, creating fragments and specifying exchange values, and terminating. and setting balance
that's it.
scenarios-> those are just query args for exch val and termination

Thus we add 'foreground' to INTERFACE_TYPES, and we create READONLY_INTERFACE_TYPES which excludes it.

Then almost all of the above cases (6 of 8) should in fact use READONLY; and only resolve() and lc_resource validation should use the full list.

 * What other changes need to be made in order to have the LcResolver handle foregrounds?

 * What queries need to be supported in the foreground query interface?
   Foreground interface is the same as inventory interface, except that it allows for the archive to contain fragments.
   = is there an affirmative characteristic of LcArchive that PREVENTS it from storing fragments? ANS: NO

Foreground audit!! Now this was recently rewritten, so I imagine it is generally useful, but let's take a look:

line 22-26: class LcForeground(LcArchive): + docstring
line 27-30: load_json_file-- this could be part of the base LcArchive; I don't see why not
line 31-46: external references mapping-- this could be part of the base LcArchive
line 47-63: __init__(path, catalog)
     Requires a catalog to deserialize fragments
     Requires that it be a foreground catalog i.e. that has an entity editor
line 64-67: editor property
line 68-77: create resolved catalog refs; also actual entities from foregrounds (DEPRECATED)
line 78-90: override add to merge instead of skipping
line 91-96: save-- write entity file, serialize fragments
line 97-167: create fragments
line 168-172: clear score caches
line 173-180: path-specific constants
line 181-240: access / retrieve fragments
line 241-245: draw tree
line 246-250: override check_counter
line 251-259: assign external references
line 260-293: load fragments
line 294-304: outmoded child_flows fn
line 305-325: save fragments
line 326-360: find linked terms and orphans.

Things to fix:
 - old child flows
 - reorganize
 - remove fragment handling from LcArchive.add(), put it into Foreground.add(). This prevents LcArchives from adding fragments.  raise (and catch?) TypeError.
 - Terminations to fragments shjould always reference the parent fragment, with the termflow used to indicate if the fragment is not being run directly.

 - figure out the upstreaming issue.  Is this just a foreground feature now? should it always and only use the catalog's native Qdb?

We need to think this over more.






==========
Tue May 02 14:53:31 -0700 2017

This is STALLED OUT.

Here's the approach:

 The CatalogRef is the magic key.  It implements all the API interfaces, and then it asks the catalog to satisfy them.
 The Catalog leans heavily on the resolver to get from a semantic ref to a physical archive.
 


==========
Tue Apr 25 15:07:52 -0700 2017

An LcCatalog provides an automated service for obtaining information about LCA data objects.

There are four different forms of (read-only) information available to be queried (see API.md):

 * Quantity data are informations about the quantitative properties of flows.  These are stored in a quantity database, which can exist independently of any inventory information.  Quantity data apply to 'flowables', often when going into or coming out of different 'compartments'.  An LcFlow is a flowable and a particular compartment.

 * Catalog data are metadata and non-quantitative data about entities, including their names, characteristics. At least a subset of these are generally publicly available for all entities.

 * Foreground data are quantitative data that describe computational information about the entities when used in models.  For flows, these include characterizations. For processes, these include exchanges.

 * Background data are quantitative data that describe the aggregated life cycle inventory or life cycle impact assessment results for processes embedded in computable databases.

When a catalog ref is looked up, the catalog specifies whether the entity is known to the catalog in a catalog, fg, or bg sense.

This means that the catalog is also separate from the foreground in a way that's different from before. it's more focused on data retrieval (as should be).

We still haven't broached the study construction- which comes next.

Thu 2017-04-27 12:17:52 -0700

But-- for the time being, the important facts are: the catalog PROVIDES access to the API routes specified in API.md.  The Catalog CAN be implemented as a web service.  The catalog CAN ALSO operate as a web CLIENT- in which case the data source would be another instance of the catalog service-- but this is a complicated step that requires the catalog to de-serialize JSON data.  That can get folded into the archive factory, though, I think.

SO, TO SUMMARIZE:
 - the LcCatalog is the culmination of the semantic catalog work. the idea is to translate a REST-style query into usable lca data. I *think* the API spec is adequate to do complete LCA. (minus uncertainty; minus study-specific allocation).

 - The catalog operates on a catalog ref, which is an origin + external ref, which should be unique.

 - the STUDY should use the catalog to obtain data and also enable the user to directly input data. Everything is fragments; nothing is processes.

 - fragments are basically exchanges, and terminations are complementary exchanges.  Thus a terminated fragment is a link.

REMAINING WORK:

 - implement the catalog, obviously

 - implement the CatalogInterface, ForegroundInterface, BackgroundInterface.  get them tested and running.  Those interfaces are eminently testable.

 - re-design the foreground to be the study-- construct fragments incrementally using the API queries.

 - for now we don't need fg lcia, since all the child flows will be rendered as fragments.  If we want, we can do something where 'flows not present as child fragments but present in the process inventory can be characterized'.  but rather than jump to that, we should AUTOMATICALLY CREATE SUB-FRAGMENTS from processes, store the process ref, and then write a routine to update fragment exchange values from queries.  best of all worlds.

 - lastly, write the web service, and get it running on the lca-tools-datafiles data.  THAT will be instantly disruptive.

time to get the bus.

PLUMBING

OK, in the interest of postponing ACTUAL PROGRAMMING for as long as possible, let's continue to think through exactly how this will work.

Fri 2017-04-28 18:23:14 -0700

OK.  SOME modest progress.




Option 1: Prototype the CatalogInterface, ForegroundInterface, and BackgroundInterface.

 * CatalogInterface inherits from NsUuidArchive
 * key is '/'.join(origin, external_ref)
 * Catalog's entity list acts as a cache -- stores non-quantitative data for all entities requested (quant too?)
 * CatalogInterface implements the API
 * CatalogInterface composed with a Qdb (separate interface)
 * CatalogInterface maintains a collection of LcArchives

 * CatalogInterface has a resolver input file that maps semantic roots to lists of data sources
   - each data source has attributes:
     = Priority - lowest priority accessed first
     = dataSourceType - argument to archive_factory
     = dataContents - controlled vocabulary: 'catalog', 'foreground', 'background'
       ** foreground provides catalog
       ** foreground archive input to BackgroundManager provides background
       ** background provides catalog
       ** background cannot provide foreground
     = ExcludeRoutes: list of API routes that the source should not provide
     = AccessControl: controlled vocabulary:
       ** 'open' -- any query is answered
       ** 'metered' -- authentication must be provided; every query is billable
       ** 'protected' -- authentication must be provided; authorization TBD
       ** ... others TBD

There is going to have to be some kind of regression.  When a query is received, the resolver needs to:
 - receive the query, including origin + ref + authentication info
 - determine whether the catalog can answer the query at all
   = determine if a source is known for the given origin
   = determine if the request is authorized to access the source
     ** list the same source multiple times?? sure-- the thing that gets 
   = determine if the query type (catalog, fg, bg) is available
 - determin
